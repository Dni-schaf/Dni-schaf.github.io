<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Höhe der Divs basierend auf Tagen</title>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <script src="../resources/js/coordinates.js"></script>
    <script src="../resources/js/iceshelf_Data.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Farsan&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="../resources/css/comicAndMap.css">

</head>
<body>
    <div id="mapbox">
        <div id="map"></div>
        <div id="grid"></div>
        <div id="path"></div>
    </div>
    <div id="datumsanzeige" style="position: fixed; top: 0px; left: 0px; width: 300px; height: 30px;"></div>

    <div class="container" id="container"></div>


   

<script src="../resources/js/comicAndMap_images.js"></script> 
<script src="../resources/js/comicAndMap_texts.js"></script> 


<script>        
        let language = "de";

        // karte erzeugen
        const svgmap = d3.select("#map").append("svg")
        .attr("width", 900)
        .attr("height", 700);

        const svgpath = d3.select("#path").append("svg")
        .attr("width", 900)
        .attr("height", 700);

        const svggrid = d3.select("#grid").append("svg")
        .attr("width", 900)
        .attr("height", 700);

        const projection = d3.geoAzimuthalEqualArea()
        .rotate([-70,0])
        .scale(170)
        .translate([450,360]);

        const path = d3.geoPath().projection(projection);

        const graticule = d3.geoGraticule()
        .step([10, 5]);



// wie viele Einträge sind im Datensatz
const datecountScott = Object.keys(Scott).length;
const datecountAmundsen = Object.keys(Amundsen).length;

// wie lang ist die dauer vom ersten bis zum letzten tag --> timestampdelta
//array in dem alle timestamps liegen

function fillTimestampArr (datecount, dataset){
  let timestempArr = [];
    for (let i=0; i<datecount; i++){
     timestempArr.push(dataset[i].timestamp);
    };
    return timestempArr;
};

let timestempArrScott = fillTimestampArr(datecountScott, Scott);
let timestempArrAmundsen = fillTimestampArr(datecountAmundsen, Amundsen);

// ermittel den ersten und den letzten tag des datensatzes
let MaxtimestampScott = Math.max(...timestempArrScott);
let MaxtimestampAmundsen = Math.max(...timestempArrAmundsen);

function getMaxtimestamp () {
  if (MaxtimestampScott > MaxtimestampAmundsen) {
    return MaxtimestampScott;
  }else{
    return MaxtimestampAmundsen;
  };
};

let Maxtimestamp = getMaxtimestamp();

let MintimestampScott = Math.min(...timestempArrScott);
let MintimestampAmundsen = Math.min(...timestempArrAmundsen);

function getMintimestamp () {
  if (MintimestampScott < MintimestampAmundsen) {
    return MintimestampScott;
  }else{
    return MintimestampAmundsen;
  };
};

let Mintimestamp = getMintimestamp();

let timestampdelta = (Maxtimestamp) - (Mintimestamp);


//Reisepfad zeichnen
function drawPath(dataset, datecount) {

//es wir je eine linie zwischen 2 tagen gezeichnet
    for (let i=0; i<datecount-1; i++){

      const lines = svgpath
        .append("line")
        .style("stroke-width", 2)
       // first point: first date
        .attr("x1", function (index) { 
          let longitude = projection([dataset[i].lng,dataset[i].lat]);
          return longitude[0];
        })
        .attr("y1", function (index) { 
          let latitude = projection([dataset[i].lng,dataset[i].lat]);
          return latitude[1];
        })
       // second point: second date
        .attr("x2", function (index) { 
          let longitude = projection([dataset[i+1].lng,dataset[i+1].lat]);
          return longitude[0];
        })
        .attr("y2", function (index) { 
          let latitude = projection([dataset[i+1].lng,dataset[i+1].lat]);
          return latitude[1];
        })
        .attr("id", function (index) {
          let setID = dataset[i+1].team + i
          return setID;
        })
        .attr("class", dataset[i].team);
    }; 
};

        
//eis in die karte zeichnen
function drawIce(){
   d3.json("https://gist.githubusercontent.com/ScharffenBerg/5fb9342bb4abe86bec09230d90275197/raw/4bfb48ab30681e6ec441b0d8a2d7a5da6583900a/Shelf_Ice_Data.json", function(error, ice) {
  if (error) return console.error(error);

  svgmap.append("g")
    .attr("class", "iceshelf")
    .selectAll("path")
    .data(ice.features)
    .enter().append("path")
    .attr('d', path)
    .attr("class", "ice"); 
  });  
};

//karte zeichnen
function drawMap(err, world) {
   if (err) throw err
  
  //macht Umriss für die Farbe des Meers
  svgmap.append("path")
    .datum(graticule.outline)
    .attr("class", "foreground")
    .attr("d", path);
  
  //Kontinente erzeugen
  svgmap.append("g")
    .selectAll("path")
    .data(topojson.feature(world, world.objects.countries).features)
    .enter().append("path")
    .attr("d", path)
    .attr("class", "map");
 
  //Gitternetz erzeugen
  svggrid.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path); 
}; 

drawIce();
d3.json("https://unpkg.com/world-atlas@1.1.4/world/110m.json", drawMap);


drawPath(Scott, datecountScott);
drawPath(Amundsen, datecountAmundsen);


        // container erzeugen

        const datestartArray = ["15.06.1910", "09.08.1910", "09.09.1910", "10.09.1910", "12.10.1910", "02.11.1910", "24.11.1910", "25.11.1910", "30.11.1910", "03.12.1910", "04.12.1910", "05.12.1910"];
        const dateendArray =   ["09.08.1910", "06.09.1910", "10.09.1910", "11.10.1910", "01.11.1910", "24.11.1910", "25.11.1910", "30.11.1910", "03.12.1910", "04.12.1910", "05.12.1910", "04.03.1911"];

        // Farben für die divs
        const colors = ["#FFCCCC", "#FFCC99", "#FFFF99", "#CCFFCC", "#99CCFF", "#CCCCFF", "#FF99CC", "#FF6666", "#FF9966", "#FFFF66", "#99FF99", "#66CCFF", "#CC99FF", "#FF66CC"];

        // Funktion, die das Datumsformat "tt.mm.jjjj" in ein Date-Objekt konvertiert
        function convertToDate(dateString) {
          const [day, month, year] = dateString.split('.');
          return new Date(`${year}-${month}-${day}`).getTime();
        }

        const timestampstartArray = datestartArray.map(convertToDate);
        const timestampendArray = dateendArray.map(convertToDate);

        // Container für die divs
        const container = document.getElementById('container');

        // Höhe des Browserfensters
        const windowHeight = window.innerHeight;

// Funktion, um ein Margin-div zu erstellen
function createMarginDiv() {
    const marginDiv = document.createElement('div');
    marginDiv.className = 'margin';
    
    // Setze die Breite auf 100% und die Höhe auf 50% der Fensterhöhe
    marginDiv.style.width = '100%';
    marginDiv.style.height = `${windowHeight}px`;
    
    return marginDiv;
}

        // Funktion, um ein Spacer-div zu erstellen und Bilder hinzuzufügen
        function createSpacerDiv(images) {
            const spacerDiv = document.createElement('div');
            spacerDiv.className = 'spacer-div';

            images.forEach(image => {

                const imgContainer = document.createElement('div');
                imgContainer.style.position = 'relative';
                imgContainer.className = 'image-container';

                const img = document.createElement('img');
                img.src = `../resources/images/${image.Kapitel}.svg`;
                img.style.width = '100%';
                imgContainer.appendChild(img);

                // Erstellen des Gitterbildes
                //const gridImg = document.createElement('img');
                //gridImg.src = '../resources/images/grid.png'; // Pfad zum Gitterbild
                //gridImg.style.position = 'absolute';
                //gridImg.style.top = 0;
                //gridImg.style.left = 0;
                //gridImg.style.width = '100%';
                //gridImg.style.height = '100%';
                //gridImg.style.pointerEvents = 'none'; // Gitterbild soll keine Mausinteraktionen beeinflussen
                //imgContainer.appendChild(gridImg);

                addTextToImage(imgContainer, image.Kapitel, language);

                spacerDiv.appendChild(imgContainer);
            });

            return spacerDiv;
        
        }

// Funktion, um Texte zum Bild hinzuzufügen
function addTextToImage(imageContainer, imageKey, language) {
    if (imageTexts[imageKey]) {
        imageTexts[imageKey].forEach(textData => {
            // Erstelle das äußere Div mit der gewünschten Klasse und den Stilen
            const textDiv = document.createElement('div');
            textDiv.className = textData.kind; // Die Klasse "dialog" und "kind" hinzufügen
            textDiv.style.bottom = textData.bottom; // Bottom-Positionierung
            textDiv.style.left = textData.left;
            textDiv.style.width = textData.width;
            textDiv.style.textAlign = textData.textAlign;

            // Erstelle das p-Element mit der gewünschten Klasse
            const pElement = document.createElement('p');
            pElement.className =  textData.color; // Klasse "txtwhite" hinzufügen

            // Erstelle das span-Element mit der gewünschten Klasse und dem Textinhalt
            const spanElement = document.createElement('span');
            spanElement.id = `${imageKey}_${textData.ID}`; // ID im gewünschten Format setzen
            spanElement.className = `highlight ${textData.backgroundColor}`; // Klasse "highlight" und Hintergrundfarbe hinzufügen
            spanElement.innerText = textData[`text_${language}`] || textData[`text_de`]; // Fallback auf Deutsch, falls die Sprache nicht vorhanden ist

            // Füge das span in das p-Element ein
            pElement.appendChild(spanElement);

            // Füge das p-Element in das Div-Element ein
            textDiv.appendChild(pElement);

            // Füge das fertige Div-Element in den Image-Container ein
            imageContainer.appendChild(textDiv);
        });
    }
}
 

        // Ersten Spacer-div mit Bildern vor dem ersten div einfügen
        container.appendChild(createSpacerDiv(imageSets[0]));

        // Schleife über die Arrays und Erstellung der divs
        for (let i = 0; i < datestartArray.length; i++) {
            const startDate = convertToDate(datestartArray[i]);
            const endDate = convertToDate(dateendArray[i]);

            // Berechnung der Tage zwischen den beiden Daten
            const timeDiff = endDate - startDate;
            const daysDiff = timeDiff / (1000 * 60 * 60 * 24);

            // Höhe des divs in Pixeln (30px pro Tag)
            const divHeight = daysDiff * 30 + windowHeight;

            // Erstellung und Styling des divs
            const dayDiv = document.createElement('div');
            dayDiv.className = 'day-div';
            // Füge die ID mit dem Timestamp des Startdatums hinzu
            dayDiv.id = `${startDate}`;
            dayDiv.style.height = `${divHeight}px`;
            dayDiv.textContent = `Start: ${datestartArray[i]} - Ende: ${dateendArray[i]} - Tage: ${daysDiff}`;

            // Hinzufügen des divs und eines Spacer-divs mit Bildern zum Container
            container.appendChild(dayDiv);

             // Füge ein margin-div zwischen day-div und spacer-div hinzu
            const marginDiv = createMarginDiv();
            container.appendChild(marginDiv);

            // Füge weitere Bildsätze hinzu, wenn vorhanden
            if (i < imageSets.length - 1) {
                container.appendChild(createSpacerDiv(imageSets[i + 1]));
            }
        }
        document.getElementById('container').appendChild(createSpacerDiv(imageSets, language));


// totalLenght ist Array mit den längen der Teilabschnitte, timeLength mit der Dauer der Abschnitte

function fillLength(datecount, team) {
   //Arrays werden befüllt
  let totalLength = [];
  for (let i=0; i<datecount-1; i++){
    let IDteam = team + i;
    let length = d3.select("#"+IDteam).node().getTotalLength();
    totalLength.push(length);
  };
  return totalLength;
};
  
let totalLengthScott = fillLength(datecountScott, "Scott");
let totalLengthAmundsen = fillLength(datecountAmundsen, "Amundsen");

  
function filltime(datecount, dataset) {
  //Arrays werden befüllt
  let timeLength = [];
  for (let i=0; i<datecount-1; i++){ 
    let time = dataset[i+1].timestamp - dataset[i].timestamp;
    timeLength.push(time);
  };
  return timeLength;
};

let timeLengthScott = filltime(datecountScott, Scott);
let timeLengthAmundsen = filltime(datecountAmundsen, Amundsen); 

//linien werden über dashoffset unsichtbar gemacht  
function hidelines (datecount, team, totalLength){
  for (let i=0; i<datecount-1; i++){
    let IDteam = team + i;
    d3.select("#"+IDteam).attr("stroke-dasharray", totalLength[i]);
    d3.select("#"+IDteam).attr("stroke-dashoffset", totalLength[i]);
  }; 
};
 
hidelines(datecountScott, "Scott", totalLengthScott); 
hidelines(datecountAmundsen, "Amundsen", totalLengthAmundsen);

function showlines (datecount, team){
  for (let i=0; i<datecount-1; i++){
    let IDteam = team + i;
    d3.select("#"+IDteam).attr("stroke-dashoffset", 0);
  }; 
};
 // ab hier geht es um die pfad animation - erstmal die vorbereitungen - ermitteln der notwendigen variablen

 let positionsArray = [];
 let activeDiv = null;
 let lastDiv = 0;

let currenttime;
let korrektur = 0;

  const dayDivHeightsArray = [];
  const spacerDivHeightsArray = [];
  const marginDivHeightsArray = [];

 let currenttimestamp = 0;

 let totalMapHeight= 0;
 let DayIndex=0;

 let divstate = "spacerdiv";

// Funktion, um die Höhen aller day-divs und spacer-div zu speichern
function getDivHeights() {


  // Hole alle day-div und spacer-div Elemente
  const dayDivs = document.querySelectorAll('.day-div');
  const spacerDivs = document.querySelectorAll('.spacer-div');
  const marginDivs = document.querySelectorAll('.margin');

  // Iteriere über die day-divs und speichere die Höhe
  dayDivs.forEach(div => {
    dayDivHeightsArray.push(div.offsetHeight);
  });

  // Iteriere über die spacer-divs und speichere die Höhe
  spacerDivs.forEach(div => {
    spacerDivHeightsArray.push(div.offsetHeight);
  });

  // Iteriere über die margin-divs und speichere die Höhe
  marginDivs.forEach(div => {
    marginDivHeightsArray.push(div.offsetHeight);
  });

  return { dayDivHeightsArray, spacerDivHeightsArray, marginDivHeightsArray };
}

// Funktion, um die Summe der day-div Höhen zu berechnen
function getTotalMapHeight(dayDivHeightsArray) {
  return dayDivHeightsArray.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
}

// konvertiert timestamp zur Datum
function konverter(){
  let date = new Date(currenttime);
  let year = date.getFullYear();
  let month = date.getMonth() + 1;
  let day = date.getDate();
  let datum = document.getElementById("datumsanzeige");
  datum.innerHTML = day + ". " + month + ". " + year;
} ; 

  //variablen erst befüllen nach laden der seite
  window.onload = function() {
    // Alle Spacer-Divs und Day-Divs holen
    const spacers = document.querySelectorAll('.spacer-div');
    const days = document.querySelectorAll('.day-div');

    // Sicherstellen, dass die Anzahl der Spacer und Days übereinstimmt
    const maxLength = Math.max(spacers.length, days.length);

    // Berechne die Y-Position relativ zum Dokument (top-Wert) für jedes Div
    for (let i = 0; i < maxLength; i++) {
        if (i < spacers.length) {
            // Position des Spacer-Divs relativ zum Dokumentanfang
            const spacerPosition = spacers[i].getBoundingClientRect().top + window.scrollY;
            positionsArray.push(spacerPosition);
        }
        if (i < days.length) {
            // Position des Day-Divs relativ zum Dokumentanfang
            const dayPosition = days[i].getBoundingClientRect().top + window.scrollY;
            positionsArray.push(dayPosition);
        }
    }

    const { dayDivHeightsArray, spacerDivHeightsArray, marginDivHeightsArray} = getDivHeights();
    totalMapHeight = getTotalMapHeight(dayDivHeightsArray);

};

function sumArrayUpToIndex(array, index) {
  let sum = 0;
  for (let i = 0; i <= index; i++) {
      sum += array[i];
  }
  return sum;
}

function setPathprogress(datecount, dataset, timestempArr, team, totalLength, timeLength, starttime){
  let scrolltop= document.documentElement.scrollTop;

  const startDate = timestampstartArray[DayIndex];
  const endDate = timestampendArray[DayIndex];

  // setzt aktuelle scrollposition ins verhältnis um so das aktuelle datum festzulegen
  let scrollposition = scrolltop - korrektur;
  currenttimestamp =((endDate-startDate) * (scrollposition ))/dayDivHeightsArray[DayIndex];
  currenttime = currenttimestamp+startDate;
  konverter();

  //das div ermitteln indem wir gerade sind
  for (let i = 0; i < positionsArray.length; i++) {
    if (scrolltop >= positionsArray[i] && (i + 1 >= positionsArray.length || scrolltop < positionsArray[i + 1])) {
      activeDiv = i;
                  
        if (activeDiv != lastDiv) {
          lastDiv = activeDiv;
          divstate = "spacerdiv";
          DayIndex = (activeDiv-1)/2;
          let SpacerIndex = activeDiv/2;

          //Korrektur der scrollposition damit die höhe der spacerdivs rausgerechnet werden
          let korrekturSpacer = sumArrayUpToIndex(spacerDivHeightsArray, SpacerIndex);
          let korrekturmargin = sumArrayUpToIndex(marginDivHeightsArray, SpacerIndex-1);
          let korrekturMap = sumArrayUpToIndex(dayDivHeightsArray, DayIndex-1);
          korrektur = korrekturMap + korrekturSpacer +korrekturmargin;

          //Wenn wir in einem daydiv sind dann geht es hier weiter
            if (datestartArray[DayIndex] !== undefined) {
              divstate = "daydiv";
              console.log(datestartArray[DayIndex]);
              const targetstartDate = timestampstartArray[DayIndex];
              const targetendDate = timestampendArray[DayIndex];
            }                
        }
                
    break;
    }
  }


// für alle nicht spacer divs wird diese funktion ausgelösst also für daydiv und margin div
  if(divstate!="spacerdiv"){

    //alle linine durchgehen und entweder füllen oder unsichtbar durch offset
    for (let i=0; i<datecount; i++){
        let IDteam = team + i;
        
        // das erste if damit die linie nicht weiter gezeichnet wird wenn datum nicht mehr im zeitraum ist
        if (currenttime < timestampendArray[DayIndex]){
          // schauen wer größer ist wird versteckt wer kleiner ist wird eingeblendet
          if (currenttime/1000>=timestempArr[i+1]){
            d3.select("#"+IDteam).attr("stroke-dashoffset", 0);
          }else{
            d3.select("#"+IDteam).attr("stroke-dashoffset", totalLength[i]);
          };
        }else{}
        
    //auswählen des abschnittest in dem wir grad mitten drin sind
    if (currenttime/1000>timestempArr[i] && currenttime/1000<timestempArr[i+1]&& currenttime < timestampendArray[DayIndex]) {
          //setzt länger des aktuellen abschnitt ins verhältnis zur relativen timestemp zeit und verändert das offset
          let dashoffset = totalLength[i]*((currenttime/1000)-timestempArr[i])/timeLength[i];
          d3.select("#"+team+i).attr("stroke-dashoffset", totalLength[i]-dashoffset);
        }else{
        };
    };  
  };

};


// achtet auf die scroll bewegung
window.addEventListener('scroll', function() {
  setPathprogress(datecountAmundsen, Amundsen, timestempArrAmundsen, "Amundsen", totalLengthAmundsen, timeLengthAmundsen, MintimestampAmundsen);
  setPathprogress(datecountScott, Scott, timestempArrScott, "Scott", totalLengthScott, timeLengthScott, MintimestampScott);
});

    </script>
</body>
</html>
